nameOverride:
fullNameOverride:
imagePullSecrets:
# - name: "image-pull-secret"

setup:
  enabled: false
  kind: install
  fromVersion:
  withDemo: false

node:
  enabled: true
  kind: Deployment
  # only used if kind is Deployment
  replicas: 1
  name: tb-node
  nameOverride: null
  fullNameOverride: null

  ## Define serviceAccount names. Defaults to fully qualified name.
  ##
  serviceAccount:
    create: true
    name:
    annotations: {}

  ## ConfigMap override where fullname is {{.Release.Name}}-{{.Values.node.configMapOverrideName}}
  ## Defining configMapOverrideName will cause templates/node/configmap.yaml
  ## to NOT generate a ConfigMap resource
  ##
  configMapOverrideName: ""

  ## ConfigMap entries
  ##
  config:
    thingsboard.yml:
      server:
        # Server bind address
        address: "0.0.0.0"
        # Server bind port
        port: "8080"
        # Server SSL configuration
        ssl:
          # Enable/disable SSL support
          enabled: "false"
          # Path to the key store that holds the SSL certificate
          key-store: "classpath:keystore/keystore.p12"
          # Password used to access the key store
          key-store-password: "thingsboard"
          # Type of the key store
          key-store-type: "PKCS12"
          # Alias that identifies the key in the key store
          key-alias: "tomcat"
        log_controller_error_stack_trace: "false"
        ws:
          send_timeout: "5000"
          limits:
            # Limit the amount of sessions and subscriptions available on each server. Put values to zero to disable particular limitation
            max_sessions_per_tenant: "0"
            max_sessions_per_customer: "0"
            max_sessions_per_regular_user: "0"
            max_sessions_per_public_user: "0"
            max_queue_per_ws_session: "500"
            max_subscriptions_per_tenant: "0"
            max_subscriptions_per_customer: "0"
            max_subscriptions_per_regular_user: "0"
            max_subscriptions_per_public_user: "0"
            max_updates_per_session: "300:1,3000:60"
        rest:
          limits:
            tenant:
              enabled: "false"
              configuration: "100:1,2000:60"
            customer:
              enabled: "false"
              configuration: "50:1,1000:60"
          server_side_rpc:
            # Minimum value of the server side RPC timeout. May override value provided in the REST API call.
            # Since 2.5 migration to queues, the RPC delay depends on the size of the pending messages in the queue,
            # so default UI parameter of 500ms may not be sufficient for loaded environments.
            min_timeout:  "5000"
            # Default value of the server side RPC timeout.
            default_timeout:  "10000"

      # Zookeeper connection parameters. Used for service discovery.
      zk:
        # Enable/disable zookeeper discovery service.
        enabled: "false"
        # Zookeeper connect string
        url: "localhost:2181"
        # Zookeeper retry interval in milliseconds
        retry_interval_ms: "3000"
        # Zookeeper connection timeout in milliseconds
        connection_timeout_ms: "3000"
        # Zookeeper session timeout in milliseconds
        session_timeout_ms: "3000"
        # Name of the directory in zookeeper 'filesystem'
        zk_dir: "/thingsboard"

      cluster:
        stats:
          enabled: "false"
          print_interval_ms: "10000"

      # Plugins configuration parameters
      plugins:
        # Comma separated package list used during classpath scanning for plugins
        scan_packages: "org.thingsboard.server.extensions,org.thingsboard.rule.engine"

      # Security parameters
      security:
        # JWT Token parameters
        jwt:
          tokenExpirationTime: "9000" # Number of seconds (2.5 hours)
          refreshTokenExpTime: "604800" # Number of seconds (1 week)
          tokenIssuer: "thingsboard.io"
          tokenSigningKey: "thingsboardDefaultSigningKey"
        # Enable/disable access to Tenant Administrators JWT token by System Administrator or Customer Users JWT token by Tenant Administrator
        user_token_access_enabled: "true"
        # Enable/disable case-sensitive username login
        user_login_case_sensitive: "true"
        claim:
          # Enable/disable claiming devices, if false -> the device's [claimingAllowed] SERVER_SCOPE attribute must be set to [true] to allow claiming specific device
          allowClaimingByDefault: "true"
          # Time allowed to claim the device in milliseconds
          duration: "60000" # 1 minute, note this value must equal claimDevices.timeToLiveInMinutes value
        basic:
          enabled: "false"
        oauth2:
          # Enable/disable OAuth 2 login functionality
          # For details please refer to https://thingsboard.io/docs/user-guide/oauth-2-support/
          enabled: "false"
          # Redirect URL where access code from external user management system will be processed
          loginProcessingUrl: "/login/oauth2/code/"
          # List of SSO clients
          clients:
            default:
              # Label that going to be show on login button - 'Login with {loginButtonLabel}'
              loginButtonLabel: "Default"
              # Icon that going to be show on login button. Material design icon ID (https://material.angularjs.org/latest/api/directive/mdIcon)
              loginButtonIcon: ""
              clientName: "ClientName"
              clientId: ""
              clientSecret: ""
              accessTokenUri: ""
              authorizationUri: ""
              scope: ""
              # Redirect URL that must be in sync with 'security.oauth2.loginProcessingUrl', but domain name added
              redirectUriTemplate: "http://localhost:8080/login/oauth2/code/"
              jwkSetUri: ""
              # 'authorization_code', 'implicit', 'refresh_token' or 'client_credentials'
              authorizationGrantType: "authorization_code"
              clientAuthenticationMethod: "post" # basic or post
              userInfoUri: ""
              userNameAttributeName: "email"
              mapperConfig:
                # Allows to create user if it not exists
                allowUserCreation: "true"
                # Allows user to setup ThingsBoard internal password and login over default Login window
                activateUser: "false"
                # Mapper type of converter from external user into internal - 'basic' or 'custom'
                type: "basic"
                basic:
                  # Key from attributes of external user object to use as email
                  emailAttributeKey: "email"
                  firstNameAttributeKey: ""
                  lastNameAttributeKey: ""
                  # Strategy for generating Tenant from external user object - 'domain', 'email' or 'custom'
                  # 'domain' - name of the Tenant will be extracted as domain from the email of the user
                  # 'email' - name of the Tenant will email of the user
                  # 'custom' - please configure 'tenantNamePattern' for custom mapping
                  tenantNameStrategy: "domain"
                  # %{attribute_key} as placeholder for attribute value of attributes of external user object
                  tenantNamePattern: ""
                  # If this field is not empty, user will be created as a user under defined Customer
                  # %{attribute_key} as placeholder for attribute value of attributes of external user object
                  customerNamePattern: ""
                  # If this field is not empty, user will be created with default defined Dashboard
                  defaultDashboardName: ""
                  # If this field is set 'true' along with non-empty 'defaultDashboardName', user will start from the defined Dashboard in fullscreen mode
                  alwaysFullScreen: "false"
                custom:
                  url: ""
                  username: ""
                  password: ""

      # Dashboard parameters
      dashboard:
        # Maximum allowed datapoints fetched by widgets
        max_datapoints_limit: "50000"

      database:
        ts_max_intervals: "700" # Max number of DB queries generated by single API call to fetch telemetry records
        ts:
          type: "sql" # cassandra, sql, or timescale (for hybrid mode, DATABASE_TS_TYPE value should be cassandra, or timescale)

      # note: timescale works only with postgreSQL database for DATABASE_ENTITIES_TYPE.

      # Cassandra driver configuration parameters
      cassandra:
        # Thingsboard cluster name
        cluster_name: "Thingsboard Cluster"
        # Thingsboard keyspace name
        keyspace_name: "thingsboard"
        # Specify node list
        url: "127.0.0.1:9042"
        # Enable/disable secure connection
        ssl: "false"
        # Enable/disable JMX
        jmx: "false"
        # Enable/disable metrics collection.
        metrics: "false"
        # NONE SNAPPY LZ4
        compression: "none"
        # Specify cassandra cluster initialization timeout in milliseconds (if no hosts available during startup)
        init_timeout_ms: "300000"
        # Specify cassandra claster initialization retry interval (if no hosts available during startup)
        init_retry_interval_ms: "3000"
        max_requests_per_connection_local: "32768"
        max_requests_per_connection_remote: "32768"
        # Credential parameters #
        credentials: "false"
        # Specify your username
        username: ""
        # Specify your password
        password: ""

        # Cassandra cluster connection socket parameters #
        socket:
          connect_timeout: "5000"
          read_timeout: "20000"
          keep_alive: "true"
          reuse_address: "true"
          so_linger: ""
          tcp_no_delay: "false"
          receive_buffer_size: ""
          send_buffer_size: ""

        # Cassandra cluster connection query parameters  #
        query:
          read_consistency_level: "ONE"
          write_consistency_level: "ONE"
          default_fetch_size: "2000"
          # Specify partitioning size for timestamp key-value storage. Example: MINUTES, HOURS, DAYS, MONTHS,INDEFINITE
          ts_key_value_partitioning: "MONTHS"
          ts_key_value_ttl: "0"
          events_ttl: "0"
          # Specify TTL of debug log in seconds. The current value corresponds to one week
          debug_events_ttl: "604800"
          buffer_size: "200000"
          concurrent_limit: "1000"
          permit_max_wait_time: "120000"
          dispatcher_threads: "2"
          callback_threads: "4"
          poll_ms: "50"
          rate_limit_print_interval_ms: "10000"
          # set all data types values except target to null for the same ts on save
          set_null_values_enabled: "false"
          # log one of cassandra queries with specified frequency (0 - logging is disabled)
          print_queries_freq: "0"
          tenant_rate_limits:
            enabled: "false"
            configuration: "1000:1,30000:60"
            print_tenant_names: "false"

      # SQL configuration parameters
      sql:
        # Specify batch size for persisting attribute updates
        attributes:
          batch_size: "10000"
          batch_max_delay: "100"
          stats_print_interval_ms: "10000"
        ts:
          batch_size: "10000"
          batch_max_delay: "100"
          stats_print_interval_ms: "10000"
        ts_latest:
          batch_size: "10000"
          batch_max_delay: "100"
          stats_print_interval_ms: "10000"
        # Specify whether to remove null characters from strValue of attributes and timeseries before insert
        remove_null_chars: "true"
        postgres:
          # Specify partitioning size for timestamp key-value storage. Example: DAYS, MONTHS, YEARS, INDEFINITE.
          ts_key_value_partitioning: "MONTHS"
        timescale:
          # Specify Interval size for new data chunks storage.
          chunk_time_interval: "604800000"
        ttl:
          ts:
            enabled: "true"
            execution_interval_ms: "86400000" # Number of milliseconds. The current value corresponds to one day
            ts_key_value_ttl: "0" # Number of seconds
          events:
            enabled: "true"
            execution_interval_ms: "86400000" # Number of milliseconds. The current value corresponds to one day
            events_ttl: "0" # Number of seconds
            debug_events_ttl: "604800" # Number of seconds. The current value corresponds to one week

      # Actor system parameters
      actors:
        system:
          throughput: "5"
          scheduler_pool_size: "1"
          max_actor_init_attempts: "10"
          app_dispatcher_pool_size: "1"
          tenant_dispatcher_pool_size: "2"
          device_dispatcher_pool_size: "4"
          rule_dispatcher_pool_size: "4"
        tenant:
          create_components_on_init: "true"
        session:
          max_concurrent_sessions_per_device: "1"
          sync:
            # Default timeout for processing request using synchronous session (HTTP, CoAP) in milliseconds
            timeout: "10000"
        rule:
          # Specify thread pool size for database request callbacks executor service
          db_callback_thread_pool_size: "50"
          # Specify thread pool size for javascript executor service
          js_thread_pool_size: "50"
          # Specify thread pool size for mail sender executor service
          mail_thread_pool_size: "50"
          # Whether to allow usage of system mail service for rules
          allow_system_mail_service: "true"
          # Specify thread pool size for external call service
          external_call_thread_pool_size: "50"
          chain:
            # Errors for particular actor are persisted once per specified amount of milliseconds
            error_persist_frequency: "3000"
            debug_mode_rate_limits_per_tenant:
              enabled: "true"
              configuration: "50000:3600"
          node:
            # Errors for particular actor are persisted once per specified amount of milliseconds
            error_persist_frequency: "3000"
          transaction:
            # Size of queues which store messages for transaction rule nodes
            queue_size: "15000"
            # Time in milliseconds for transaction to complete
            duration: "60000"
        statistics:
          # Enable/disable actor statistics
          enabled: "true"
          js_print_interval_ms: "10000"
          persist_frequency: "3600000"

      cache:
        # caffeine or redis
        type: "caffeine"

      caffeine:
        specs:
          relations:
            timeToLiveInMinutes: 1440
            maxSize: 100000
          deviceCredentials:
            timeToLiveInMinutes: 1440
            maxSize: 100000
          devices:
            timeToLiveInMinutes: 1440
            maxSize: 100000
          sessions:
            timeToLiveInMinutes: 1440
            maxSize: 100000
          assets:
            timeToLiveInMinutes: 1440
            maxSize: 100000
          entityViews:
            timeToLiveInMinutes: 1440
            maxSize: 100000
          claimDevices:
            timeToLiveInMinutes: 1
            maxSize: 100000
          securitySettings:
            timeToLiveInMinutes: 1440
            maxSize: 1

      redis:
        # standalone or cluster
        connection:
          type: "standalone"
        standalone:
          host: "localhost"
          port: "6379"
          useDefaultClientConfig: "true"
          # this value may be used only if you used not default ClientConfig
          clientName: "standalone"
          # this value may be used only if you used not default ClientConfig
          connectTimeout: "30000"
          # this value may be used only if you used not default ClientConfig
          readTimeout: "60000"
          # this value may be used only if you used not default ClientConfig
          usePoolConfig: "false"
        cluster:
          # Comma-separated list of "host:port" pairs to bootstrap from.
          nodes: ""
          # Maximum number of redirects to follow when executing commands across the cluster.
          max-redirects: "12"
          useDefaultPoolConfig: "true"
        # db index
        db: "0"
        # db password
        password: ""
        # pool config
        pool_config:
          maxTotal: "128"
          maxIdle: "128"
          minIdle: "16"
          testOnBorrow: "true"
          testOnReturn: "true"
          testWhileIdle: "true"
          minEvictableMs: "60000"
          evictionRunsMs: "30000"
          maxWaitMills: "60000"
          numberTestsPerEvictionRun: "3"
          blockWhenExhausted: "true"

      # Check new version updates parameters
      updates:
        # Enable/disable updates checking.
        enabled: "true"

      # spring CORS configuration
      spring.mvc.cors:
        mappings:
          # Intercept path
          "[/api/**]":
            #Comma-separated list of origins to allow. '*' allows all origins. When not set,CORS support is disabled.
            allowed-origins: "*"
            #Comma-separated list of methods to allow. '*' allows all methods.
            allowed-methods: "*"
            #Comma-separated list of headers to allow in a request. '*' allows all headers.
            allowed-headers: "*"
            #How long, in seconds, the response from a pre-flight request can be cached by clients.
            max-age: "1800"
            #Set whether credentials are supported. When not set, credentials are not supported.
            allow-credentials: "true"

      # spring serve gzip compressed static resources
      spring.resources.chain:
        compressed: "true"
        strategy:
          content:
            enabled: "true"

      spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation: "true"
      spring.jpa.properties.hibernate.order_by.default_null_ordering: "last"

      # SQL DAO Configuration
      spring:
        data:
          jpa:
            repositories:
              enabled: "true"
        jpa:
          open-in-view: "false"
          hibernate:
            ddl-auto: "none"
          database-platform: "org.hibernate.dialect.PostgreSQLDialect"
        datasource:
          driverClassName: "org.postgresql.Driver"
          url: "jdbc:postgresql://localhost:5432/thingsboard"
          username: "postgres"
          password: "postgres"
          hikari:
            maximumPoolSize: "5"

      # Audit log parameters
      audit-log:
        # Enable/disable audit log functionality.
        enabled: "true"
        # Specify partitioning size for audit log by tenant id storage. Example MINUTES, HOURS, DAYS, MONTHS
        by_tenant_partitioning: "MONTHS"
        # Number of days as history period if startTime and endTime are not specified
        default_query_period: "30"
        # Logging levels per each entity type.
        # Allowed values: OFF (disable), W (log write operations), RW (log read and write operations)
        logging-level:
          mask:
            "device": "W"
            "asset": "W"
            "dashboard": "W"
            "customer": "W"
            "user": "W"
            "rule_chain": "W"
            "alarm": "W"
            "entity_view": "W"
        sink:
          # Type of external sink. possible options: none, elasticsearch
          type: "none"
          # Name of the index where audit logs stored
          # Index name could contain next placeholders (not mandatory):
          # @{TENANT} - substituted by tenant ID
          # @{DATE} - substituted by current date in format provided in audit_log.sink.date_format
          index_pattern: "@{TENANT}_AUDIT_LOG_@{DATE}"
          # Date format. Details of the pattern could be found here:
          # https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html
          date_format: "YYYY.MM.DD"
          scheme_name: "http" # http or https
          host: "localhost"
          port: "9200"
          user_name: ""
          password: ""

      state:
        # Should be greater then transport.sessions.report_timeout
        defaultInactivityTimeoutInSec: "600"
        defaultStateCheckIntervalInSec: "60"
        persistToTelemetry: "false"

      js:
        evaluator: "local" # local/remote
        # Built-in JVM JavaScript environment properties
        local:
          # Use Sandboxed (secured) JVM JavaScript environment
          use_js_sandbox: "true"
          # Specify thread pool size for JavaScript sandbox resource monitor
          monitor_thread_pool_size: "4"
          # Maximum CPU time in milliseconds allowed for script execution
          max_cpu_time: "10000"
          # Maximum allowed JavaScript execution errors before JavaScript will be blacklisted
          max_errors: "3"
          # JS Eval max request timeout. 0 - no timeout
          max_requests_timeout: "0"
          # Maximum time in seconds for black listed function to stay in the list.
          max_black_list_duration_sec: "60"
          stats:
            enabled: "false"
            print_interval_ms: "10000"
        # Remote JavaScript environment properties
        remote:
          # Maximum allowed JavaScript execution errors before JavaScript will be blacklisted
          max_errors: "3"
          # Maximum time in seconds for black listed function to stay in the list.
          max_black_list_duration_sec: "60"
          stats:
            enabled: "false"
            print_interval_ms: "10000"

      transport:
        sessions:
          inactivity_timeout: "300000"
          report_timeout: "30000"
        rate_limits:
          enabled: "false"
          tenant: "1000:1,20000:60"
          device: "10:1,300:60"
        json:
          # Cast String data types to Numeric if possible when processing Telemetry/Attributes JSON
          type_cast_enabled: "true"
          # Maximum allowed string value length when processing Telemetry/Attributes JSON (0 value disables string value length check)
          max_string_value_length: "0"
        client_side_rpc:
          timeout:  "60000"
        # Local HTTP transport parameters
        http:
          enabled: "true"
          request_timeout: "60000"
        # Local MQTT transport parameters
        mqtt:
          # Enable/disable mqtt transport protocol.
          enabled: "true"
          bind_address: "0.0.0.0"
          bind_port: "1883"
          timeout: "10000"
          netty:
            leak_detector_level: "DISABLED"
            boss_group_thread_count: "1"
            worker_group_thread_count: "12"
            max_payload_size: "65536"
            so_keep_alive: "false"
          # MQTT SSL configuration
          ssl:
            # Enable/disable SSL support
            enabled: "false"
            # SSL protocol: See http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#SSLContext
            protocol: "TLSv1.2"
            # Path to the key store that holds the SSL certificate
            key_store: "mqttserver.jks"
            # Password used to access the key store
            key_store_password: "server_ks_password"
            # Password used to access the key
            key_password: "server_key_password"
            # Type of the key store
            key_store_type: "JKS"
        # Local CoAP transport parameters
        coap:
          # Enable/disable coap transport protocol.
          enabled: "true"
          bind_address: "0.0.0.0"
          bind_port: "5683"
          timeout: "10000"

      swagger:
        api_path_regex: "/api.*"
        security_path_regex: "/api.*"
        non_security_path_regex: "/api/noauth.*"
        title: "ThingsBoard REST API"
        description: "For instructions how to authorize requests please visit <a href='http://thingsboard.io/docs/reference/rest-api/'>REST API documentation page</a>."
        contact:
          name: "Thingsboard team"
          url: "http://thingsboard.io"
          email: "info@thingsboard.io"
        license:
          title: "Apache License Version 2.0"
          url: "https://github.com/thingsboard/thingsboard/blob/master/LICENSE"
        version: "2.0"

      queue:
        type: "in-memory" # in-memory or kafka (Apache Kafka) or aws-sqs (AWS SQS) or pubsub (PubSub) or service-bus (Azure Service Bus) or rabbitmq (RabbitMQ)
        kafka:
          bootstrap.servers: "localhost:9092"
          acks: "all"
          retries: "1"
          batch.size: "16384"
          linger.ms: "1"
          buffer.memory: "33554432"
          replication_factor: "1"
          max_poll_records: "8192"
          max_partition_fetch_bytes: "16777216"
          fetch_max_bytes: "134217728"
          topic-properties:
            rule-engine: "retention.ms:604800000;segment.bytes:26214400;retention.bytes:1048576000"
            core: "retention.ms:604800000;segment.bytes:26214400;retention.bytes:1048576000"
            transport-api: "retention.ms:604800000;segment.bytes:26214400;retention.bytes:1048576000"
            notifications: "retention.ms:604800000;segment.bytes:26214400;retention.bytes:1048576000"
            js-executor: "retention.ms:604800000;segment.bytes:26214400;retention.bytes:104857600"
        aws_sqs:
          access_key_id: "YOUR_KEY"
          secret_access_key: "YOUR_SECRET"
          region: "YOUR_REGION"
          threads_per_topic: "1"
          queue-properties:
            rule-engine: "VisibilityTimeout:30;MaximumMessageSize:262144;MessageRetentionPeriod:604800"
            core: "VisibilityTimeout:30;MaximumMessageSize:262144;MessageRetentionPeriod:604800"
            transport-api: "VisibilityTimeout:30;MaximumMessageSize:262144;MessageRetentionPeriod:604800"
            notifications: "VisibilityTimeout:30;MaximumMessageSize:262144;MessageRetentionPeriod:604800"
            js-executor: "VisibilityTimeout:30;MaximumMessageSize:262144;MessageRetentionPeriod:604800"
            #    VisibilityTimeout in seconds;MaximumMessageSize in bytes;MessageRetentionPeriod in seconds
        pubsub:
          project_id: "YOUR_PROJECT_ID"
          service_account: "YOUR_SERVICE_ACCOUNT"
          max_msg_size: "1048576" #in bytes
          max_messages: "1000"
          queue-properties:
            rule-engine: "ackDeadlineInSec:30;messageRetentionInSec:604800"
            core: "ackDeadlineInSec:30;messageRetentionInSec:604800"
            transport-api: "ackDeadlineInSec:30;messageRetentionInSec:604800"
            notifications: "ackDeadlineInSec:30;messageRetentionInSec:604800"
            js-executor: "ackDeadlineInSec:30;messageRetentionInSec:604800"
        service_bus:
          namespace_name: "YOUR_NAMESPACE_NAME"
          sas_key_name: "YOUR_SAS_KEY_NAME"
          sas_key: "YOUR_SAS_KEY"
          max_messages: "1000"
          queue-properties:
            rule-engine: "lockDurationInSec:30;maxSizeInMb:1024;messageTimeToLiveInSec:604800"
            core: "lockDurationInSec:30;maxSizeInMb:1024;messageTimeToLiveInSec:604800"
            transport-api: "lockDurationInSec:30;maxSizeInMb:1024;messageTimeToLiveInSec:604800"
            notifications: "lockDurationInSec:30;maxSizeInMb:1024;messageTimeToLiveInSec:604800"
            js-executor: "lockDurationInSec:30;maxSizeInMb:1024;messageTimeToLiveInSec:604800"
        rabbitmq:
          exchange_name: ""
          host: "localhost"
          port: "5672"
          virtual_host: "/"
          username: "YOUR_USERNAME"
          password: "YOUR_PASSWORD"
          automatic_recovery_enabled: "false"
          connection_timeout: "60000"
          handshake_timeout: "10000"
          queue-properties:
            rule-engine: "x-max-length-bytes:1048576000;x-message-ttl:604800000"
            core: "x-max-length-bytes:1048576000;x-message-ttl:604800000"
            transport-api: "x-max-length-bytes:1048576000;x-message-ttl:604800000"
            notifications: "x-max-length-bytes:1048576000;x-message-ttl:604800000"
            js-executor: "x-max-length-bytes:1048576000;x-message-ttl:604800000"
        partitions:
          hash_function_name: "murmur3_128" # murmur3_32, murmur3_128 or sha256
        transport_api:
          requests_topic: "tb_transport.api.requests"
          responses_topic: "tb_transport.api.responses"
          max_pending_requests: "10000"
          max_requests_timeout: "10000"
          max_callback_threads: "100"
          request_poll_interval: "25"
          response_poll_interval: "25"
        core:
          topic: "tb_core"
          poll-interval: "25"
          partitions: "10"
          pack-processing-timeout: "2000"
          stats:
            enabled: "true"
            print-interval-ms: "60000"
        js:
          # JS Eval request topic
          request_topic: "js_eval.requests"
          # JS Eval responses topic prefix that is combined with node id
          response_topic_prefix: "js_eval.responses"
          # JS Eval max pending requests
          max_pending_requests: "10000"
          # JS Eval max request timeout
          max_eval_requests_timeout: "60000"
          # JS max request timeout
          max_requests_timeout: "10000"
          # JS response poll interval
          response_poll_interval: "25"
          # JS response auto commit interval
          response_auto_commit_interval: "100"
        rule-engine:
          topic: "tb_rule_engine"
          poll-interval: "25"
          pack-processing-timeout: "2000"
          stats:
            enabled: "true"
            print-interval-ms: "60000"
          queues:
            - name: "Main"
              topic: "tb_rule_engine.main"
              poll-interval: "25"
              partitions: "10"
              pack-processing-timeout: "2000"
              submit-strategy:
                type: "BURST" # BURST, BATCH, SEQUENTIAL_BY_ORIGINATOR, SEQUENTIAL_BY_TENANT, SEQUENTIAL
                # For BATCH only
                batch-size: "1000" # Maximum number of messages in batch
              processing-strategy:
                type: "SKIP_ALL_FAILURES" # SKIP_ALL_FAILURES, RETRY_ALL, RETRY_FAILED, RETRY_TIMED_OUT, RETRY_FAILED_AND_TIMED_OUT
                # For RETRY_ALL, RETRY_FAILED, RETRY_TIMED_OUT, RETRY_FAILED_AND_TIMED_OUT
                retries: "3" # Number of retries, 0 is unlimited
                failure-percentage: "0" # Skip retry if failures or timeouts are less then X percentage of messages;
                pause-between-retries: "3"# Time in seconds to wait in consumer thread before retries;
            - name: "HighPriority"
              topic: "tb_rule_engine.hp"
              poll-interval: "25"
              partitions: "10"
              pack-processing-timeout: "2000"
              submit-strategy:
                type: "BURST" # BURST, BATCH, SEQUENTIAL_BY_ORIGINATOR, SEQUENTIAL_BY_TENANT, SEQUENTIAL
                # For BATCH only
                batch-size: "100" # Maximum number of messages in batch
              processing-strategy:
                type: "RETRY_FAILED_AND_TIMED_OUT" # SKIP_ALL_FAILURES, RETRY_ALL, RETRY_FAILED, RETRY_TIMED_OUT, RETRY_FAILED_AND_TIMED_OUT
                # For RETRY_ALL, RETRY_FAILED, RETRY_TIMED_OUT, RETRY_FAILED_AND_TIMED_OUT
                retries: "0" # Number of retries, 0 is unlimited
                failure-percentage: "0" # Skip retry if failures or timeouts are less then X percentage of messages;
                pause-between-retries: "5"# Time in seconds to wait in consumer thread before retries;
            - name: "SequentialByOriginator"
              topic: "tb_rule_engine.sq"
              poll-interval: "25"
              partitions: "10"
              pack-processing-timeout: "2000"
              submit-strategy:
                type: "SEQUENTIAL_BY_ORIGINATOR" # BURST, BATCH, SEQUENTIAL_BY_ORIGINATOR, SEQUENTIAL_BY_TENANT, SEQUENTIAL
                # For BATCH only
                batch-size: "100" # Maximum number of messages in batch
              processing-strategy:
                type: "RETRY_FAILED_AND_TIMED_OUT" # SKIP_ALL_FAILURES, RETRY_ALL, RETRY_FAILED, RETRY_TIMED_OUT, RETRY_FAILED_AND_TIMED_OUT
                # For RETRY_ALL, RETRY_FAILED, RETRY_TIMED_OUT, RETRY_FAILED_AND_TIMED_OUT
                retries: "3" # Number of retries, 0 is unlimited
                failure-percentage: "0" # Skip retry if failures or timeouts are less then X percentage of messages;
                pause-between-retries: "5"# Time in seconds to wait in consumer thread before retries;
        transport:
          # For high priority notifications that require minimum latency and processing time
          notifications_topic: "tb_transport.notifications"
          poll_interval: "25"

      service:
        type: "monolith" # monolith or tb-core or tb-rule-engine
        # Unique id for this service (autogenerated if empty)
        id: "${CLUSTER_NODE_ID:}"
        tenant_id: "" # empty or specific tenant id.

    logback.xml: |
      <!DOCTYPE configuration>
            <configuration scan="true" scanPeriod="10 seconds">
                <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
                    <encoder>
                        <pattern>%d{ISO8601} [%thread] %-5level %logger{36} - %msg%n</pattern>
                    </encoder>
                </appender>

                <logger name="org.thingsboard.server" level="INFO" />
                <logger name="com.google.common.util.concurrent.AggregateFuture" level="OFF" />

                <root level="INFO">
                    <appender-ref ref="STDOUT"/>
                </root>
            </configuration>
    thingsboard.conf: |
      export JAVA_OPTS="$JAVA_OPTS -Dspring.config.location=/usr/share/thingsboard/conf/,/usr/share/thingsboard/extensions/,/config/"
      export JAVA_OPTS="$JAVA_OPTS -Dplatform=deb -Dinstall.data_dir=/usr/share/thingsboard/data"
      export LOG_FILENAME=/dev/stdout
      export LOADER_PATH=""

  livenessProbe:
    initialDelay: 300
    periodSeconds: 15
    timeoutSeconds: 10
    failureThreshold: 3
    successThreshold: 1

  image:
    repository: thingsboard/tb-node
    pullPolicy: IfNotPresent

  ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/
  ##
  podSecurityPolicy:
    annotations: {}
      ## Specify pod annotations
      ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#apparmor
      ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#seccomp
      ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#sysctl
      ##
      # seccomp.security.alpha.kubernetes.io/allowedProfileNames: '*'
      # seccomp.security.alpha.kubernetes.io/defaultProfileName: 'docker/default'
    # apparmor.security.beta.kubernetes.io/defaultProfileName: 'runtime/default'

  priorityClassName: ""

  updateStrategy:
    type: RollingUpdate

  ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
  ##
  tolerations: []
    # - key: "key"
    #   operator: "Equal|Exists"
    #   value: "value"
  #   effect: "NoSchedule|PreferNoSchedule|NoExecute(1.6 only)"

  ## Ref: https://kubernetes.io/docs/user-guide/node-selection/
  ##
  nodeSelector: {}

  ## Annotations to be added to pods
  ##
  podAnnotations: {}

  ## Labels to be added to pods
  ##
  pod:
    labels: {}

  ## PodDisruptionBudget settings
  ## ref: https://kubernetes.io/docs/concepts/workloads/pods/disruptions/
  ##
  podDisruptionBudget:
    enabled: false
    maxUnavailable: 1

  ## Ref: https://kubernetes.io/docs/user-guide/compute-resources/
  ##
  resources: {}
    # limits:
    #   cpu: 200m
    #   memory: 50Mi
    # requests:
  #   cpu: 100m
  #   memory: 30Mi

  ## Security context to be added to node-exporter pods
  ##
  securityContext: {}
  # runAsUser: 0

  affinity: {}

  service:
    servicePort:
      name: http
      port: 8080
      targetPort: http
      protocol: TCP

    annotations:
      prometheus.io/scrape: "true"
    labels: {}
    type: ClusterIP

  ingress:
    ## If true, Ingress will be created
    ##
    enabled: false

    ## Ingress annotations
    ##
    annotations: {}
    #   kubernetes.io/ingress.class: nginx
    #   kubernetes.io/tls-acme: 'true'

    ## Ingress additional labels
    ##
    extraLabels: {}

    ## Ingress hostname
    ## Must be provided if Ingress is enabled
    ##
    host: ""
    paths:
      - /api
      - /swagger
      - /webjars
      - /v2
      - /static/rulenode
      - /oauth2
      - /login/oauth2

    ## Ingress TLS configuration
    ##
    tls: false

web:
  enabled: true
  kind: Deployment
  # only used if kind is Deployment
  replicas: 1
  name: tb-web-ui
  nameOverride: null
  fullNameOverride: null

  ## Define serviceAccount names. Defaults to fully qualified name.
  ##
  serviceAccount:
    create: true
    name:
    annotations: {}

  ## ConfigMap override where fullname is {{.Release.Name}}-{{.Values.node.configMapOverrideName}}
  ## Defining configMapOverrideName will cause templates/node/configmap.yaml
  ## to NOT generate a ConfigMap resource
  ##
  configMapOverrideName: ""

  ## ConfigMap entries
  ##
  config:
    tb-web-ui.conf: |
      export NODE_CONFIG_DIR=/usr/share/tb-web-ui/conf
      export DOCKER_MODE=true
      export WEB_FOLDER=/usr/share/tb-web-ui/web
      export NODE_ENV=default
    default.yml:
      server:
        # Server bind address
        address: "0.0.0.0"
        # Server bind port
        port: "8080"
      thingsboard:
        enableProxy: "false"
        # ThingsBoard node host
        host: "localhost"
        # ThingsBoard node port
        port: "8080"
      logger:
        level: "debug"
        path: "/dev"
        filename: "stdout"
    logger.js: |
      var config = require('config'),
          path = require('path'),
          DailyRotateFile = require('winston-daily-rotate-file');

      const { createLogger, format, transports } = require('winston');
      const { combine, timestamp, label, printf, splat } = format;

      var loggerTransports = [];

      if (process.env.NODE_ENV !== 'production' || process.env.DOCKER_MODE === 'true') {
          loggerTransports.push(new transports.Console({
              handleExceptions: true
          }));
      } else {
          var filename = path.join(config.get('logger.path'), config.get('logger.filename'));
          var transport = new (DailyRotateFile)({
              filename: filename,
              datePattern: 'YYYY-MM-DD-HH',
              zippedArchive: true,
              maxSize: '20m',
              maxFiles: '14d',
              handleExceptions: true
          });
          loggerTransports.push(transport);
      }

      const tbFormat = printf(info => {
          return `$${info.timestamp} [$${info.label}] $${info.level.toUpperCase()}: $${info.message}`;
      });

      function _logger(moduleLabel) {
          return createLogger({
              level: config.get('logger.level'),
              format:combine(
                  splat(),
                  label({ label: moduleLabel }),
                  timestamp({format: 'YYYY-MM-DD HH:mm:ss,SSS'}),
                  tbFormat
              ),
              transports: loggerTransports
          });
      }
  livenessProbe:
    initialDelay: 300
    periodSeconds: 15
    timeoutSeconds: 10
    failureThreshold: 3
    successThreshold: 1

  image:
    repository: thingsboard/tb-web-ui
    pullPolicy: IfNotPresent

  ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/
  ##
  podSecurityPolicy:
    annotations: {}
      ## Specify pod annotations
      ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#apparmor
      ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#seccomp
      ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#sysctl
      ##
      # seccomp.security.alpha.kubernetes.io/allowedProfileNames: '*'
    # seccomp.security.alpha.kubernetes.io/defaultProfileName: 'docker/default'
    # apparmor.security.beta.kubernetes.io/defaultProfileName: 'runtime/default'

  priorityClassName: ""

  updateStrategy:
    type: RollingUpdate

  ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
  ##
  tolerations: []
    # - key: "key"
    #   operator: "Equal|Exists"
  #   value: "value"
  #   effect: "NoSchedule|PreferNoSchedule|NoExecute(1.6 only)"

  ## Ref: https://kubernetes.io/docs/user-guide/node-selection/
  ##
  nodeSelector: {}

  affinity: {}

  ## Annotations to be added to pods
  ##
  podAnnotations: {}

  ## Labels to be added to pods
  ##
  pod:
    labels: {}

  ## PodDisruptionBudget settings
  ## ref: https://kubernetes.io/docs/concepts/workloads/pods/disruptions/
  ##
  podDisruptionBudget:
    enabled: false
    maxUnavailable: 1

  ## Ref: https://kubernetes.io/docs/user-guide/compute-resources/
  ##
  resources: {}
    # limits:
    #   cpu: 200m
    #   memory: 50Mi
  # requests:
  #   cpu: 100m
  #   memory: 30Mi

  ## Security context to be added to node-exporter pods
  ##
  securityContext: {}
  # runAsUser: 0

  service:
    servicePort:
      name: http
      port: 8080
      targetPort: http
      protocol: TCP

    annotations:
      prometheus.io/scrape: "true"
    labels: {}
    type: ClusterIP

  ingress:
    ## If true, Ingress will be created
    ##
    enabled: false

    ## Ingress annotations
    ##
    annotations: {}
    #   kubernetes.io/ingress.class: nginx
    #   kubernetes.io/tls-acme: 'true'

    ## Ingress additional labels
    ##
    extraLabels: {}

    ## Ingress hostname
    ## Must be provided if Ingress is enabled
    ##
    host: ""
    paths:
      - /static/
      - /index.html
      - /

    ## Ingress TLS configuration
    ##
    tls: false

js:
  enabled: false
  kind: Deployment
  # only used if kind is Deployment
  replicas: 1
  name: tb-js-executor
  nameOverride: null
  fullNameOverride: null

  env: {}

  ## Define serviceAccount names. Defaults to fully qualified name.
  ##
  serviceAccount:
    create: true
    name:
    annotations: {}

  ## ConfigMap override where fullname is {{.Release.Name}}-{{.Values.node.configMapOverrideName}}
  ## Defining configMapOverrideName will cause templates/node/configmap.yaml
  ## to NOT generate a ConfigMap resource
  ##
  configMapOverrideName: ""

  image:
    repository: thingsboard/tb-js-executor
    pullPolicy: IfNotPresent

  ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/
  ##
  podSecurityPolicy:
    annotations: {}
      ## Specify pod annotations
      ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#apparmor
    ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#seccomp
    ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#sysctl
    ##
    # seccomp.security.alpha.kubernetes.io/allowedProfileNames: '*'
    # seccomp.security.alpha.kubernetes.io/defaultProfileName: 'docker/default'
    # apparmor.security.beta.kubernetes.io/defaultProfileName: 'runtime/default'

  priorityClassName: ""

  updateStrategy:
    type: RollingUpdate

  ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
  ##
  tolerations: []
  # - key: "key"
  #   operator: "Equal|Exists"
  #   value: "value"
  #   effect: "NoSchedule|PreferNoSchedule|NoExecute(1.6 only)"

  ## Ref: https://kubernetes.io/docs/user-guide/node-selection/
  ##
  nodeSelector: {}

  affinity: {}

  ## Annotations to be added to pods
  ##
  podAnnotations: {}

  ## Labels to be added to pods
  ##
  pod:
    labels: {}

  ## PodDisruptionBudget settings
  ## ref: https://kubernetes.io/docs/concepts/workloads/pods/disruptions/
  ##
  podDisruptionBudget:
    enabled: false
    maxUnavailable: 1

  ## Ref: https://kubernetes.io/docs/user-guide/compute-resources/
  ##
  resources: {}
  # limits:
  #   cpu: 200m
  #   memory: 50Mi
  # requests:
  #   cpu: 100m
  #   memory: 30Mi

  ## Security context to be added to node-exporter pods
  ##
  securityContext: {}
  # runAsUser: 0

transport:
  http:
    enabled: false
    kind: Deployment
    # only used if kind is Deployment
    replicas: 1
    name: tb-http-transport
    nameOverride: null
    fullNameOverride: null

    ## Define serviceAccount names. Defaults to fully qualified name.
    ##
    serviceAccount:
      create: true
      name:
      annotations: {}

    ## ConfigMap override where fullname is {{.Release.Name}}-{{.Values.node.configMapOverrideName}}
    ## Defining configMapOverrideName will cause templates/node/configmap.yaml
    ## to NOT generate a ConfigMap resource
    ##
    configMapOverrideName: ""

    ## ConfigMap entries
    ##
    config:
      tb-http-transport.conf: |
        export JAVA_OPTS="$JAVA_OPTS -Dspring.config.location=/usr/share/tb-http-transport/conf/,/config/"
        export LOG_FILENAME=/dev/stdout
        export LOADER_PATH=""
      logback.xml: |
        <?xml version="1.0" encoding="UTF-8" ?>
        <!--

            Copyright © 2016-2020 The Thingsboard Authors

            Licensed under the Apache License, Version 2.0 (the "License");
            you may not use this file except in compliance with the License.
            You may obtain a copy of the License at

                http://www.apache.org/licenses/LICENSE-2.0

            Unless required by applicable law or agreed to in writing, software
            distributed under the License is distributed on an "AS IS" BASIS,
            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
            See the License for the specific language governing permissions and
            limitations under the License.

        -->
        <!DOCTYPE configuration>
        <configuration scan="true" scanPeriod="10 seconds">

            <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
                <encoder>
                    <pattern>%d{ISO8601} [%thread] %-5level %logger{36} - %msg%n</pattern>
                </encoder>
            </appender>

            <logger name="org.thingsboard.server" level="TRACE" />

            <logger name="com.microsoft.azure.servicebus.primitives.CoreMessageReceiver" level="OFF" />

            <root level="INFO">
                <appender-ref ref="STDOUT"/>
            </root>

        </configuration>
      tb-http-transport.yml:
        server:
          # Server bind address
          address: "0.0.0.0"
          # Server bind port
          port: "8080"

        # Zookeeper connection parameters. Used for service discovery.
        zk:
          # Enable/disable zookeeper discovery service.
          enabled: "false"
          # Zookeeper connect string
          url: "localhost:2181"
          # Zookeeper retry interval in milliseconds
          retry_interval_ms: "3000"
          # Zookeeper connection timeout in milliseconds
          connection_timeout_ms: "3000"
          # Zookeeper session timeout in milliseconds
          session_timeout_ms: "3000"
          # Name of the directory in zookeeper 'filesystem'
          zk_dir: "/thingsboard"

        # HTTP server parameters
        transport:
          http:
            request_timeout: "60000"
          sessions:
            inactivity_timeout: "300000"
            report_timeout: "30000"
          rate_limits:
            enabled: "false"
            tenant: "1000:1,20000:60"
            device: "10:1,300:60"
          json:
            # Cast String data types to Numeric if possible when processing Telemetry/Attributes JSON
            type_cast_enabled: "true"
            # Maximum allowed string value length when processing Telemetry/Attributes JSON (0 value disables string value length check)
            max_string_value_length: "0"

        queue:
          type: "kafka" # kafka (Apache Kafka) or aws-sqs (AWS SQS) or pubsub (PubSub) or service-bus (Azure Service Bus) or rabbitmq (RabbitMQ)
          kafka:
            bootstrap.servers: "localhost:9092"
            acks: "all"
            retries: "1"
            batch.size: "16384"
            linger.ms: "1"
            buffer.memory: "33554432"
            replication_factor: "1"
            topic-properties:
              rule-engine: "retention.ms:604800000;segment.bytes:26214400;retention.bytes:1048576000"
              core: "retention.ms:604800000;segment.bytes:26214400;retention.bytes:1048576000"
              transport-api: "retention.ms:604800000;segment.bytes:26214400;retention.bytes:1048576000"
              notifications: "retention.ms:604800000;segment.bytes:26214400;retention.bytes:1048576000"
              js-executor: "retention.ms:604800000;segment.bytes:26214400;retention.bytes:104857600"
          aws_sqs:
            access_key_id: "YOUR_KEY"
            secret_access_key: "YOUR_SECRET"
            region: "YOUR_REGION"
            threads_per_topic: "1"
            queue-properties:
              rule-engine: "VisibilityTimeout:30;MaximumMessageSize:262144;MessageRetentionPeriod:604800"
              core: "VisibilityTimeout:30;MaximumMessageSize:262144;MessageRetentionPeriod:604800"
              transport-api: "VisibilityTimeout:30;MaximumMessageSize:262144;MessageRetentionPeriod:604800"
              notifications: "VisibilityTimeout:30;MaximumMessageSize:262144;MessageRetentionPeriod:604800"
              js-executor: "VisibilityTimeout:30;MaximumMessageSize:262144;MessageRetentionPeriod:604800"
              #    VisibilityTimeout in seconds;MaximumMessageSize in bytes;MessageRetentionPeriod in seconds
          pubsub:
            project_id: "YOUR_PROJECT_ID"
            service_account: "YOUR_SERVICE_ACCOUNT"
            max_msg_size: "1048576" #in bytes
            max_messages: "1000"
            queue-properties:
              rule-engine: "ackDeadlineInSec:30;messageRetentionInSec:604800"
              core: "ackDeadlineInSec:30;messageRetentionInSec:604800"
              transport-api: "ackDeadlineInSec:30;messageRetentionInSec:604800"
              notifications: "ackDeadlineInSec:30;messageRetentionInSec:604800"
              js-executor: "ackDeadlineInSec:30;messageRetentionInSec:604800"
          service_bus:
            namespace_name: "YOUR_NAMESPACE_NAME"
            sas_key_name: "YOUR_SAS_KEY_NAME"
            sas_key: "YOUR_SAS_KEY"
            max_messages: "1000"
            queue-properties:
              rule-engine: "lockDurationInSec:30;maxSizeInMb:1024;messageTimeToLiveInSec:604800"
              core: "lockDurationInSec:30;maxSizeInMb:1024;messageTimeToLiveInSec:604800"
              transport-api: "lockDurationInSec:30;maxSizeInMb:1024;messageTimeToLiveInSec:604800"
              notifications: "lockDurationInSec:30;maxSizeInMb:1024;messageTimeToLiveInSec:604800"
              js-executor: "lockDurationInSec:30;maxSizeInMb:1024;messageTimeToLiveInSec:604800"
          rabbitmq:
            exchange_name: ""
            host: "localhost"
            port: "5672"
            virtual_host: "/"
            username: "YOUR_USERNAME"
            password: "YOUR_PASSWORD"
            automatic_recovery_enabled: "false"
            connection_timeout: "60000"
            handshake_timeout: "10000"
            queue-properties:
              rule-engine: "x-max-length-bytes:1048576000;x-message-ttl:604800000"
              core: "x-max-length-bytes:1048576000;x-message-ttl:604800000"
              transport-api: "x-max-length-bytes:1048576000;x-message-ttl:604800000"
              notifications: "x-max-length-bytes:1048576000;x-message-ttl:604800000"
              js-executor: "x-max-length-bytes:1048576000;x-message-ttl:604800000"
          partitions:
            hash_function_name: "murmur3_128"
            virtual_nodes_size: "16"
          transport_api:
            requests_topic: "tb_transport.api.requests"
            responses_topic: "tb_transport.api.responses"
            max_pending_requests: "10000"
            max_requests_timeout: "10000"
            max_callback_threads: "100"
            request_poll_interval: "25"
            response_poll_interval: "25"
          core:
            topic: "tb_core"
            poll-interval: "25"
            partitions: "10"
            pack-processing-timeout: "60000"
            stats:
              enabled: "false"
              print-interval-ms: "10000"
          js:
            # JS Eval request topic
            request_topic: "js_eval.requests"
            # JS Eval responses topic prefix that is combined with node id
            response_topic_prefix: "js_eval.responses"
            # JS Eval max pending requests
            max_pending_requests: "10000"
            # JS Eval max request timeout
            max_requests_timeout: "10000"
            # JS response poll interval
            response_poll_interval: "25"
            # JS response auto commit interval
            response_auto_commit_interval: "100"
          rule-engine:
            topic: "tb_rule_engine"
            poll-interval: "25"
            pack-processing-timeout: "60000"
            stats:
              enabled: "true"
              print-interval-ms: "60000"
            queues:
              - name: "Main"
                topic: "tb_rule_engine.main"
                poll-interval: "25"
                partitions: "10"
                pack-processing-timeout: "60000"
                submit-strategy:
                  type: "BURST" # BURST, BATCH, SEQUENTIAL_BY_ORIGINATOR, SEQUENTIAL_BY_TENANT, SEQUENTIAL
                  # For BATCH only
                  batch-size: "1000" # Maximum number of messages in batch
                processing-strategy:
                  type: "SKIP_ALL_FAILURES" # SKIP_ALL_FAILURES, RETRY_ALL, RETRY_FAILED, RETRY_TIMED_OUT, RETRY_FAILED_AND_TIMED_OUT
                  # For RETRY_ALL, RETRY_FAILED, RETRY_TIMED_OUT, RETRY_FAILED_AND_TIMED_OUT
                  retries: "3" # Number of retries, 0 is unlimited
                  failure-percentage: "0" # Skip retry if failures or timeouts are less then X percentage of messages;
                  pause-between-retries: "3"# Time in seconds to wait in consumer thread before retries;
              - name: "HighPriority"
                topic: "tb_rule_engine.hp"
                poll-interval: "25"
                partitions: "10"
                pack-processing-timeout: "60000"
                submit-strategy:
                  type: "BURST" # BURST, BATCH, SEQUENTIAL_BY_ORIGINATOR, SEQUENTIAL_BY_TENANT, SEQUENTIAL
                  # For BATCH only
                  batch-size: "100" # Maximum number of messages in batch
                processing-strategy:
                  type: "RETRY_FAILED_AND_TIMED_OUT" # SKIP_ALL_FAILURES, RETRY_ALL, RETRY_FAILED, RETRY_TIMED_OUT, RETRY_FAILED_AND_TIMED_OUT
                  # For RETRY_ALL, RETRY_FAILED, RETRY_TIMED_OUT, RETRY_FAILED_AND_TIMED_OUT
                  retries: "0" # Number of retries, 0 is unlimited
                  failure-percentage: "0" # Skip retry if failures or timeouts are less then X percentage of messages;
                  pause-between-retries: "5"# Time in seconds to wait in consumer thread before retries;
              - name: "SequentialByOriginator"
                topic: "tb_rule_engine.sq"
                poll-interval: "25"
                partitions: "10"
                pack-processing-timeout: "60000"
                submit-strategy:
                  type: "SEQUENTIAL_BY_ORIGINATOR" # BURST, BATCH, SEQUENTIAL_BY_ORIGINATOR, SEQUENTIAL_BY_TENANT, SEQUENTIAL
                  # For BATCH only
                  batch-size: "100" # Maximum number of messages in batch
                processing-strategy:
                  type: "RETRY_FAILED_AND_TIMED_OUT" # SKIP_ALL_FAILURES, RETRY_ALL, RETRY_FAILED, RETRY_TIMED_OUT, RETRY_FAILED_AND_TIMED_OUT
                  # For RETRY_ALL, RETRY_FAILED, RETRY_TIMED_OUT, RETRY_FAILED_AND_TIMED_OUT
                  retries: "3" # Number of retries, 0 is unlimited
                  failure-percentage: "0" # Skip retry if failures or timeouts are less then X percentage of messages;
                  pause-between-retries: "5"# Time in seconds to wait in consumer thread before retries;
          transport:
            # For high priority notifications that require minimum latency and processing time
            notifications_topic: "tb_transport.notifications"
            poll_interval: "25"

        service:
          type: "tb-transport"
          # Unique id for this service (autogenerated if empty)
          id: "${CLUSTER_NODE_ID:}"
          tenant_id: "" # empty or specific tenant id.

    livenessProbe:
      initialDelay: 120
      periodSeconds: 20
      timeoutSeconds: 10
      failureThreshold: 3
      successThreshold: 1

    image:
      repository: thingsboard/tb-http-transport
      pullPolicy: IfNotPresent

    ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/
    ##
    podSecurityPolicy:
      annotations: {}
        ## Specify pod annotations
        ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#apparmor
        ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#seccomp
        ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#sysctl
      ##
      # seccomp.security.alpha.kubernetes.io/allowedProfileNames: '*'
      # seccomp.security.alpha.kubernetes.io/defaultProfileName: 'docker/default'
      # apparmor.security.beta.kubernetes.io/defaultProfileName: 'runtime/default'

    priorityClassName: ""

    updateStrategy:
      type: RollingUpdate

    ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
    ##
    tolerations: []
    # - key: "key"
    #   operator: "Equal|Exists"
    #   value: "value"
    #   effect: "NoSchedule|PreferNoSchedule|NoExecute(1.6 only)"

    ## Ref: https://kubernetes.io/docs/user-guide/node-selection/
    ##
    nodeSelector: {}

    affinity: {}

    ## Annotations to be added to pods
    ##
    podAnnotations: {}

    ## Labels to be added to pods
    ##
    pod:
      labels: {}

    ## PodDisruptionBudget settings
    ## ref: https://kubernetes.io/docs/concepts/workloads/pods/disruptions/
    ##
    podDisruptionBudget:
      enabled: false
      maxUnavailable: 1

    ## Ref: https://kubernetes.io/docs/user-guide/compute-resources/
    ##
    resources: {}
      # limits:
    #   cpu: 200m
    #   memory: 50Mi
    # requests:
    #   cpu: 100m
    #   memory: 30Mi

    ## Security context to be added to node-exporter pods
    ##
    securityContext: {}
    # runAsUser: 0

    service:
      servicePort:
        name: http
        port: 8080
        targetPort: http
        protocol: TCP

      annotations:
        prometheus.io/scrape: "true"
      labels: {}
      type: ClusterIP

    ingress:
      ## If true, Ingress will be created
      ##
      enabled: false

      ## Ingress annotations
      ##
      annotations: {}
      #   kubernetes.io/ingress.class: nginx
      #   kubernetes.io/tls-acme: 'true'

      ## Ingress additional labels
      ##
      extraLabels: {}

      ## Ingress hostname
      ## Must be provided if Ingress is enabled
      ##
      host: ""
      paths:
        - /api/v1

      ## Ingress TLS configuration
      ##
      tls: false

  mqtt:
    enabled: false
    kind: Deployment
    # only used if kind is Deployment
    replicas: 1
    name: tb-mqtt-transport
    nameOverride: null
    fullNameOverride: null

    ## Define serviceAccount names. Defaults to fully qualified name.
    ##
    serviceAccount:
      create: true
      name:
      annotations: {}

    ## ConfigMap override where fullname is {{.Release.Name}}-{{.Values.node.configMapOverrideName}}
    ## Defining configMapOverrideName will cause templates/node/configmap.yaml
    ## to NOT generate a ConfigMap resource
    ##
    configMapOverrideName: ""

    ## ConfigMap entries
    ##
    config:
      tb-mqtt-transport.conf: |
        export JAVA_OPTS="$JAVA_OPTS -Dspring.config.location=/usr/share/tb-mqtt-transport/conf/,/config/"
        export LOG_FILENAME=/dev/stdout
        export LOADER_PATH=""
      logback.xml: |
        <?xml version="1.0" encoding="UTF-8" ?>
        <!--

            Copyright © 2016-2020 The Thingsboard Authors

            Licensed under the Apache License, Version 2.0 (the "License");
            you may not use this file except in compliance with the License.
            You may obtain a copy of the License at

                http://www.apache.org/licenses/LICENSE-2.0

            Unless required by applicable law or agreed to in writing, software
            distributed under the License is distributed on an "AS IS" BASIS,
            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
            See the License for the specific language governing permissions and
            limitations under the License.

        -->
        <!DOCTYPE configuration>
        <configuration scan="true" scanPeriod="10 seconds">

            <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
                <encoder>
                    <pattern>%d{ISO8601} [%thread] %-5level %logger{36} - %msg%n</pattern>
                </encoder>
            </appender>

            <logger name="org.thingsboard.server" level="TRACE" />

            <logger name="com.microsoft.azure.servicebus.primitives.CoreMessageReceiver" level="OFF" />

            <root level="INFO">
                <appender-ref ref="STDOUT"/>
            </root>

        </configuration>
      tb-mqtt-transport.yml:
        spring.main.web-environment: false
        spring.main.web-application-type: none

        # Zookeeper connection parameters. Used for service discovery.
        zk:
          # Enable/disable zookeeper discovery service.
          enabled: "false"
          # Zookeeper connect string
          url: "localhost:2181"
          # Zookeeper retry interval in milliseconds
          retry_interval_ms: "3000"
          # Zookeeper connection timeout in milliseconds
          connection_timeout_ms: "3000"
          # Zookeeper session timeout in milliseconds
          session_timeout_ms: "3000"
          # Name of the directory in zookeeper 'filesystem'
          zk_dir: "/thingsboard"

        # MQTT server parameters
        transport:
          mqtt:
            bind_address: "0.0.0.0"
            bind_port: "1883"
            adaptor: "JsonMqttAdaptor"
            timeout: "10000"
            netty:
              leak_detector_level: "DISABLED"
              boss_group_thread_count: "1"
              worker_group_thread_count: "12"
              max_payload_size: "65536"
              so_keep_alive: "false"
            # MQTT SSL configuration
            ssl:
              # Enable/disable SSL support
              enabled: "false"
              # SSL protocol: See http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#SSLContext
              protocol: "TLSv1.2"
              # Path to the key store that holds the SSL certificate
              key_store: "mqttserver.jks"
              # Password used to access the key store
              key_store_password: "server_ks_password"
              # Password used to access the key
              key_password: "server_key_password"
              # Type of the key store
              key_store_type: "JKS"
          sessions:
            inactivity_timeout: "300000"
            report_timeout: "30000"
          rate_limits:
            enabled: "false"
            tenant: "1000:1,20000:60"
            device: "10:1,300:60"
          json:
            # Cast String data types to Numeric if possible when processing Telemetry/Attributes JSON
            type_cast_enabled: "true"
            # Maximum allowed string value length when processing Telemetry/Attributes JSON (0 value disables string value length check)
            max_string_value_length: "0"

        queue:
          type: "kafka" # kafka (Apache Kafka) or aws-sqs (AWS SQS) or pubsub (PubSub) or service-bus (Azure Service Bus) or rabbitmq (RabbitMQ)
          kafka:
            bootstrap.servers: "localhost:9092"
            acks: "all"
            retries: "1"
            batch.size: "16384"
            linger.ms: "1"
            buffer.memory: "33554432"
            replication_factor: "1"
            topic-properties:
              rule-engine: "retention.ms:604800000;segment.bytes:26214400;retention.bytes:1048576000"
              core: "retention.ms:604800000;segment.bytes:26214400;retention.bytes:1048576000"
              transport-api: "retention.ms:604800000;segment.bytes:26214400;retention.bytes:1048576000"
              notifications: "retention.ms:604800000;segment.bytes:26214400;retention.bytes:1048576000"
              js-executor: "retention.ms:604800000;segment.bytes:26214400;retention.bytes:104857600"
          aws_sqs:
            access_key_id: "YOUR_KEY"
            secret_access_key: "YOUR_SECRET"
            region: "YOUR_REGION"
            threads_per_topic: "1"
            queue-properties:
              rule-engine: "VisibilityTimeout:30;MaximumMessageSize:262144;MessageRetentionPeriod:604800"
              core: "VisibilityTimeout:30;MaximumMessageSize:262144;MessageRetentionPeriod:604800"
              transport-api: "VisibilityTimeout:30;MaximumMessageSize:262144;MessageRetentionPeriod:604800"
              notifications: "VisibilityTimeout:30;MaximumMessageSize:262144;MessageRetentionPeriod:604800"
              js-executor: "VisibilityTimeout:30;MaximumMessageSize:262144;MessageRetentionPeriod:604800"
              #    VisibilityTimeout in seconds;MaximumMessageSize in bytes;MessageRetentionPeriod in seconds
          pubsub:
            project_id: "YOUR_PROJECT_ID"
            service_account: "YOUR_SERVICE_ACCOUNT"
            max_msg_size: "1048576" #in bytes
            max_messages: "1000"
            queue-properties:
              rule-engine: "ackDeadlineInSec:30;messageRetentionInSec:604800"
              core: "ackDeadlineInSec:30;messageRetentionInSec:604800"
              transport-api: "ackDeadlineInSec:30;messageRetentionInSec:604800"
              notifications: "ackDeadlineInSec:30;messageRetentionInSec:604800"
              js-executor: "ackDeadlineInSec:30;messageRetentionInSec:604800"
          service_bus:
            namespace_name: "YOUR_NAMESPACE_NAME"
            sas_key_name: "YOUR_SAS_KEY_NAME"
            sas_key: "YOUR_SAS_KEY"
            max_messages: "1000"
            queue-properties:
              rule-engine: "lockDurationInSec:30;maxSizeInMb:1024;messageTimeToLiveInSec:604800"
              core: "lockDurationInSec:30;maxSizeInMb:1024;messageTimeToLiveInSec:604800"
              transport-api: "lockDurationInSec:30;maxSizeInMb:1024;messageTimeToLiveInSec:604800"
              notifications: "lockDurationInSec:30;maxSizeInMb:1024;messageTimeToLiveInSec:604800"
              js-executor: "lockDurationInSec:30;maxSizeInMb:1024;messageTimeToLiveInSec:604800"
          rabbitmq:
            exchange_name: ""
            host: "localhost"
            port: "5672"
            virtual_host: "/"
            username: "YOUR_USERNAME"
            password: "YOUR_PASSWORD"
            automatic_recovery_enabled: "false"
            connection_timeout: "60000"
            handshake_timeout: "10000"
            queue-properties:
              rule-engine: "x-max-length-bytes:1048576000;x-message-ttl:604800000"
              core: "x-max-length-bytes:1048576000;x-message-ttl:604800000"
              transport-api: "x-max-length-bytes:1048576000;x-message-ttl:604800000"
              notifications: "x-max-length-bytes:1048576000;x-message-ttl:604800000"
              js-executor: "x-max-length-bytes:1048576000;x-message-ttl:604800000"
          partitions:
            hash_function_name: "murmur3_128"
            virtual_nodes_size: "16"
          transport_api:
            requests_topic: "tb_transport.api.requests"
            responses_topic: "tb_transport.api.responses"
            max_pending_requests: "10000"
            max_requests_timeout: "10000"
            max_callback_threads: "100"
            request_poll_interval: "25"
            response_poll_interval: "25"
          core:
            topic: "tb_core"
            poll-interval: "25"
            partitions: "10"
            pack-processing-timeout: "60000"
            stats:
              enabled: "false"
              print-interval-ms: "10000"
          js:
            # JS Eval request topic
            request_topic: "js_eval.requests"
            # JS Eval responses topic prefix that is combined with node id
            response_topic_prefix: "js_eval.responses"
            # JS Eval max pending requests
            max_pending_requests: "10000"
            # JS Eval max request timeout
            max_requests_timeout: "10000"
            # JS response poll interval
            response_poll_interval: "25"
            # JS response auto commit interval
            response_auto_commit_interval: "100"
          rule-engine:
            topic: "tb_rule_engine"
            poll-interval: "25"
            pack-processing-timeout: "60000"
            stats:
              enabled: "true"
              print-interval-ms: "60000"
            queues:
              - name: "Main"
                topic: "tb_rule_engine.main"
                poll-interval: "25"
                partitions: "10"
                pack-processing-timeout: "60000"
                submit-strategy:
                  type: "BURST" # BURST, BATCH, SEQUENTIAL_BY_ORIGINATOR, SEQUENTIAL_BY_TENANT, SEQUENTIAL
                  # For BATCH only
                  batch-size: "1000" # Maximum number of messages in batch
                processing-strategy:
                  type: "SKIP_ALL_FAILURES" # SKIP_ALL_FAILURES, RETRY_ALL, RETRY_FAILED, RETRY_TIMED_OUT, RETRY_FAILED_AND_TIMED_OUT
                  # For RETRY_ALL, RETRY_FAILED, RETRY_TIMED_OUT, RETRY_FAILED_AND_TIMED_OUT
                  retries: "3" # Number of retries, 0 is unlimited
                  failure-percentage: "0" # Skip retry if failures or timeouts are less then X percentage of messages;
                  pause-between-retries: "3"# Time in seconds to wait in consumer thread before retries;
              - name: "HighPriority"
                topic: "tb_rule_engine.hp"
                poll-interval: "25"
                partitions: "10"
                pack-processing-timeout: "60000"
                submit-strategy:
                  type: "BURST" # BURST, BATCH, SEQUENTIAL_BY_ORIGINATOR, SEQUENTIAL_BY_TENANT, SEQUENTIAL
                  # For BATCH only
                  batch-size: "100" # Maximum number of messages in batch
                processing-strategy:
                  type: "RETRY_FAILED_AND_TIMED_OUT" # SKIP_ALL_FAILURES, RETRY_ALL, RETRY_FAILED, RETRY_TIMED_OUT, RETRY_FAILED_AND_TIMED_OUT
                  # For RETRY_ALL, RETRY_FAILED, RETRY_TIMED_OUT, RETRY_FAILED_AND_TIMED_OUT
                  retries: "0" # Number of retries, 0 is unlimited
                  failure-percentage: "0" # Skip retry if failures or timeouts are less then X percentage of messages;
                  pause-between-retries: "5"# Time in seconds to wait in consumer thread before retries;
              - name: "SequentialByOriginator"
                topic: "tb_rule_engine.sq"
                poll-interval: "25"
                partitions: "10"
                pack-processing-timeout: "60000"
                submit-strategy:
                  type: "SEQUENTIAL_BY_ORIGINATOR" # BURST, BATCH, SEQUENTIAL_BY_ORIGINATOR, SEQUENTIAL_BY_TENANT, SEQUENTIAL
                  # For BATCH only
                  batch-size: "100" # Maximum number of messages in batch
                processing-strategy:
                  type: "RETRY_FAILED_AND_TIMED_OUT" # SKIP_ALL_FAILURES, RETRY_ALL, RETRY_FAILED, RETRY_TIMED_OUT, RETRY_FAILED_AND_TIMED_OUT
                  # For RETRY_ALL, RETRY_FAILED, RETRY_TIMED_OUT, RETRY_FAILED_AND_TIMED_OUT
                  retries: "3" # Number of retries, 0 is unlimited
                  failure-percentage: "0" # Skip retry if failures or timeouts are less then X percentage of messages;
                  pause-between-retries: "5"# Time in seconds to wait in consumer thread before retries;
          transport:
            # For high priority notifications that require minimum latency and processing time
            notifications_topic: "tb_transport.notifications"
            poll_interval: "25"

        service:
          type: "tb-transport"
          # Unique id for this service (autogenerated if empty)
          id: "${CLUSTER_NODE_ID:}"
          tenant_id: "" # empty or specific tenant id.
    livenessProbe:
      initialDelay: 300
      periodSeconds: 15
      timeoutSeconds: 10
      failureThreshold: 3
      successThreshold: 1

    image:
      repository: thingsboard/tb-mqtt-transport
      pullPolicy: IfNotPresent

    ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/
    ##
    podSecurityPolicy:
      annotations: {}
        ## Specify pod annotations
        ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#apparmor
      ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#seccomp
      ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#sysctl
      ##
      # seccomp.security.alpha.kubernetes.io/allowedProfileNames: '*'
      # seccomp.security.alpha.kubernetes.io/defaultProfileName: 'docker/default'
      # apparmor.security.beta.kubernetes.io/defaultProfileName: 'runtime/default'

    priorityClassName: ""

    updateStrategy:
      type: RollingUpdate

    ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
    ##
    tolerations: []
    # - key: "key"
    #   operator: "Equal|Exists"
    #   value: "value"
    #   effect: "NoSchedule|PreferNoSchedule|NoExecute(1.6 only)"

    ## Ref: https://kubernetes.io/docs/user-guide/node-selection/
    ##
    nodeSelector: {}

    affinity: {}

    ## Annotations to be added to pods
    ##
    podAnnotations: {}

    ## Labels to be added to pods
    ##
    pod:
      labels: {}

    ## PodDisruptionBudget settings
    ## ref: https://kubernetes.io/docs/concepts/workloads/pods/disruptions/
    ##
    podDisruptionBudget:
      enabled: false
      maxUnavailable: 1

    ## Ref: https://kubernetes.io/docs/user-guide/compute-resources/
    ##
    resources: {}
    # limits:
    #   cpu: 200m
    #   memory: 50Mi
    # requests:
    #   cpu: 100m
    #   memory: 30Mi

    ## Security context to be added to node-exporter pods
    ##
    securityContext: {}
    # runAsUser: 0

    service:
      servicePort:
        name: mqtt
        port: 1883
        targetPort: mqtt
        protocol: TCP

      annotations:
        prometheus.io/scrape: "true"
      labels: {}
      type: ClusterIP

    ingress:
      ## If true, Ingress will be created
      ##
      enabled: false

      ## Ingress annotations
      ##
      annotations: {}
      #   kubernetes.io/ingress.class: nginx
      #   kubernetes.io/tls-acme: 'true'

      ## Ingress additional labels
      ##
      extraLabels: {}

      ## Ingress hostname
      ## Must be provided if Ingress is enabled
      ##
      host: ""
      paths:
        - /static/
        - /index.html
        - /

      ## Ingress TLS configuration
      ##
      tls: false

postgres:
  enabled: false

redis:
  enabled: false

kafka:
  enabled: false

haproxy:
  enabled: false
  controller:
    kind: Deployment
    tcp:
      1883: thingsboard/thingsboard-tb-mqtt-transport:1883

    service:
      type: LoadBalancer
      externalTrafficPolicy: Cluster
